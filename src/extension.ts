/* eslint-disable no-console */
/* global console */


// import * as vscode from "vscode";

// let humanLines = 0;
// let aiLines = 0;
// let currentPanel: vscode.WebviewPanel | null = null;

// // Keep the latest document text-change data for debounce
// let pendingChange: vscode.TextDocumentChangeEvent | null = null;
// let debounceTimer: NodeJS.Timeout | null = null;

// // Output channel for logs
// const outputChannel = vscode.window.createOutputChannel("AI Tracker Logs");

// // Decorations
// const humanDecoration = vscode.window.createTextEditorDecorationType({
//   backgroundColor: "rgba(76,175,80,0.15)",
// });
// const aiDecoration = vscode.window.createTextEditorDecorationType({
//   backgroundColor: "rgba(244,67,54,0.15)",
// });

// function log(message: string, data?: any) {
//   const full = data ? `${message} ${JSON.stringify(data)}` : message;
//   console.log(full);
//   outputChannel.appendLine(full);
// }

// function sendUpdateToDashboard() {
//   if (currentPanel?.webview) {
//     currentPanel.webview.postMessage({ human: humanLines, ai: aiLines });
//   }
// }

// // Debounce helper
// function scheduleProcess(change: vscode.TextDocumentChangeEvent) {
//   pendingChange = change;
//   if (debounceTimer) clearTimeout(debounceTimer);
//   debounceTimer = setTimeout(() => {
//     if (pendingChange) processChange(pendingChange);
//     pendingChange = null;
//   }, 200); // process at most 5 times per second
// }

// function processChange(event: vscode.TextDocumentChangeEvent) {
//   if (!event.contentChanges.length) return;

//   let insertedChars = 0;
//   let insertedLines = 0;

//   for (const c of event.contentChanges) {
//     if (c.text.length > 0) {
//       insertedChars += c.text.length;
//       insertedLines += c.text.split("\n").length - 1;
//     }
//   }

//   // Heuristics
//   const insertedText = event.contentChanges.map((c) => c.text).join("");
//   const isAI =
//     insertedText.length > 200 ||
//     insertedText.split("\n").length > 3 ||
//     /Generated by|AI|Copilot|ChatGPT|Codeium/i.test(insertedText);

//   if (isAI) aiLines += Math.max(1, insertedLines);
//   else humanLines += Math.max(1, insertedLines);

//   log("🧮 Updated counts", { humanLines, aiLines, insertedLines, insertedChars });

//   vscode.window.activeTextEditor?.setDecorations(
//     isAI ? aiDecoration : humanDecoration,
//     event.contentChanges.map((c) => ({
//       range: new vscode.Range(c.range.start, c.range.end),
//       hoverMessage: isAI ? "🤖 AI code" : "👨‍💻 Human code",
//     }))
//   );

//   sendUpdateToDashboard();
// }

// // ---------------- Activate ----------------
// export function activate(context: vscode.ExtensionContext) {
//   outputChannel.show(true);
//   log("🚀 AI Tracker Extension activated");

//   const statusBar = vscode.window.createStatusBarItem(
//     vscode.StatusBarAlignment.Left,
//     100
//   );
//   statusBar.text = "👨‍💻 Human: 0 | 🤖 AI: 0";
//   statusBar.show();
//   context.subscriptions.push(statusBar);

//   vscode.workspace.onDidChangeTextDocument((event) => {
//     // Ignore programmatic or untitled files
//     if (event.document.uri.scheme !== "file") return;
//     // Ignore formatting-only edits
//     if (!event.contentChanges.some((c) => c.text.length > 0)) return;
//     scheduleProcess(event);
//   });

//   // ------------- Dashboard -------------
//   const showDashboard = vscode.commands.registerCommand("aianalytics.showStats", () => {
//     if (currentPanel) {
//       currentPanel.reveal(vscode.ViewColumn.One);
//       return;
//     }

//     currentPanel = vscode.window.createWebviewPanel(
//       "aiStats",
//       "AI vs Human Stats",
//       vscode.ViewColumn.One,
//       { enableScripts: true }
//     );

//     context.subscriptions.push(currentPanel);
//     const htmlPath = vscode.Uri.joinPath(context.extensionUri, "src", "dashboard.html");

//     vscode.workspace.fs.readFile(htmlPath).then((data) => {
//       let html = data.toString();
//       html = html.replace(
//         "</body>",
//         `
//         <script>
//           const HUMAN_VALUE = ${humanLines};
//           const AI_VALUE = ${aiLines};
//         </script>
//       </body>`
//       );
//       currentPanel!.webview.html = html;
//       log("📊 Dashboard opened", { humanLines, aiLines });

//       currentPanel!.webview.onDidReceiveMessage((msg) => {
//         if (msg === "ready") sendUpdateToDashboard();
//         if (msg.command === "reset") {
//           humanLines = 0;
//           aiLines = 0;
//           vscode.window.showInformationMessage("AI Tracker stats reset.");
//           sendUpdateToDashboard();
//         }
//       });
//     });

//     currentPanel.onDidDispose(() => {
//       log("🪣 Dashboard closed");
//       currentPanel = null;
//     });
//   });

//   context.subscriptions.push(showDashboard);
// }

// export function deactivate() {
//   humanDecoration.dispose();
//   aiDecoration.dispose();
//   log("🧹 Extension deactivated");
// }



/* eslint-disable no-console */
import * as vscode from "vscode";

let humanLines = 0;
let aiLines = 0;
let currentPanel: vscode.WebviewPanel | null = null;
let debounceTimer: ReturnType<typeof setTimeout> | null = null;
let pendingChange: vscode.TextDocumentChangeEvent | null = null;
let statusBar: vscode.StatusBarItem;

// Output logs
const outputChannel = vscode.window.createOutputChannel("AI Tracker Logs");

// Decorations
const humanDecoration = vscode.window.createTextEditorDecorationType({
  backgroundColor: "rgba(76,175,80,0.15)",
  overviewRulerColor: "rgba(76,175,80,0.7)",
  overviewRulerLane: vscode.OverviewRulerLane.Right,
});
const aiDecoration = vscode.window.createTextEditorDecorationType({
  backgroundColor: "rgba(244,67,54,0.15)",
  overviewRulerColor: "rgba(244,67,54,0.7)",
  overviewRulerLane: vscode.OverviewRulerLane.Right,
});

function log(message: string, data?: any) {
  const msg = data ? `${message} ${JSON.stringify(data)}` : message;
  console.log(msg);
  outputChannel.appendLine(msg);
}

function sendUpdateToDashboard() {
  if (currentPanel?.webview) {
    currentPanel.webview.postMessage({ human: humanLines, ai: aiLines });
  }
}

function updateStatusBar() {
  if (statusBar) {
    statusBar.text = `👨‍💻 ${humanLines} | 🤖 ${aiLines}`;
    statusBar.show();
  }
}

// ---------------- Debounce ----------------
function scheduleProcess(change: vscode.TextDocumentChangeEvent) {
  pendingChange = change;
  if (debounceTimer) clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    if (pendingChange) processChange(pendingChange);
    pendingChange = null;
  }, 300);
}

// ---------------- Core Logic ----------------
function processChange(event: vscode.TextDocumentChangeEvent) {
  if (!event.contentChanges.length) return;

  let insertedLines = 0;
  let isAI = false;

  // Count actual *new lines* only (not every keystroke)
  for (const c of event.contentChanges) {
    const added = c.text.split("\n").length - 1;
    if (added > 0) insertedLines += added;
  }
  if (insertedLines === 0) return; // nothing new on line level

  const insertedText = event.contentChanges.map((c) => c.text).join("");
  const looksLikeAI =
    insertedLines > 3 ||
    insertedText.length > 200 ||
    /Generated by|AI|Copilot|ChatGPT|Codeium/i.test(insertedText);

  if (looksLikeAI) {
    isAI = true;
    aiLines += insertedLines;
  } else {
    isAI = false;
    humanLines += insertedLines;
  }

  const editor = vscode.window.activeTextEditor;
  if (editor) {
    const aiRanges: vscode.DecorationOptions[] = [];
    const humanRanges: vscode.DecorationOptions[] = [];

    for (const change of event.contentChanges) {
      if (!change.text.includes("\n")) continue; // only highlight new lines
      const start = change.range.start;
      const end = editor.document.positionAt(
        editor.document.offsetAt(start) + change.text.length
      );
      const range = new vscode.Range(start, end);

      if (isAI)
        aiRanges.push({
          range,
          hoverMessage: "🤖 AI-generated code",
        });
      else
        humanRanges.push({
          range,
          hoverMessage: "👨‍💻 Human-written code",
        });
    }

    editor.setDecorations(aiDecoration, aiRanges);
    editor.setDecorations(humanDecoration, humanRanges);
  }

  log("🧮 Updated (line-based)", { humanLines, aiLines, insertedLines });
  updateStatusBar();
  sendUpdateToDashboard();
}

// ---------------- Activate ----------------
export function activate(context: vscode.ExtensionContext) {
  outputChannel.show(true);
  log("🚀 AI Tracker (line-based) activated");

  statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
  updateStatusBar();
  context.subscriptions.push(statusBar);

  vscode.workspace.onDidChangeTextDocument((event) => {
    if (event.document.uri.scheme !== "file") return;
    if (!event.contentChanges.some((c) => c.text.length > 0)) return;
    scheduleProcess(event);
  });

  // -------- Dashboard Command --------
  const showDashboard = vscode.commands.registerCommand(
    "aianalytics.showStats",
    () => {
      if (currentPanel) {
        currentPanel.reveal(vscode.ViewColumn.One);
        return;
      }

      currentPanel = vscode.window.createWebviewPanel(
        "aiStats",
        "AI vs Human Live Stats",
        vscode.ViewColumn.One,
        { enableScripts: true }
      );
      context.subscriptions.push(currentPanel);

      const htmlPath = vscode.Uri.joinPath(context.extensionUri, "src", "dashboard.html");
      vscode.workspace.fs.readFile(htmlPath).then((data) => {
        let html = data.toString();
        html = html.replace(
          "</body>",
          `
          <script>
            const HUMAN_VALUE = ${humanLines};
            const AI_VALUE = ${aiLines};
          </script>
        </body>`
        );
        currentPanel!.webview.html = html;
        log("📊 Dashboard opened", { humanLines, aiLines });

        currentPanel!.webview.onDidReceiveMessage((msg) => {
          if (msg === "ready") sendUpdateToDashboard();
          if (msg.command === "reset") {
            humanLines = 0;
            aiLines = 0;
            vscode.window.showInformationMessage("AI Tracker stats reset.");
            updateStatusBar();
            sendUpdateToDashboard();
          }
        });
      });

      currentPanel.onDidDispose(() => {
        log("🪣 Dashboard closed");
        currentPanel = null;
      });
    }
  );

  context.subscriptions.push(showDashboard);
}

export function deactivate() {
  humanDecoration.dispose();
  aiDecoration.dispose();
  log("🧹 Extension deactivated");
}
